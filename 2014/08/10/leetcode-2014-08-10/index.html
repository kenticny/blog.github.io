<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一个有思想的程序员的技术博客,Golang,Node.js,Python"><title>LeetCode 刷题笔记 - 第三期 | LUPUB.com</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">LeetCode 刷题笔记 - 第三期</h1><a id="logo" href="/.">LUPUB.com</a><p class="description">一个有思想的程序员</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LeetCode 刷题笔记 - 第三期</h1><div class="post-meta">Aug 10, 2014</div><div class="post-content"><p>时隔很长时间，再来一篇。挑选一道题，看上去是很简单的一道题，但是优化的算法比较难想到。<del>（反正我是没想到 TAT）</del></p>
<p>而且这么长时间以后才发现题目是有编号的…所以今天的题目编号是 <code>136</code></p>
<p>题目如下：</p>
<blockquote>
<p>Single Number</p>
<p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note:</p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<p>大致意思就是给定一个非空整数数组，找出只出现一次的元素。要求是线性时间复杂度和不使用额外的内存空间。</p>
<p>例如：给定数组为：<code>[1,2,1,2,3]</code>，输出结果为 <code>3</code></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>第一想法很简单，强行遍历比对：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    f := nums[i]</span><br><span class="line">    isFound := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> j != i &amp;&amp; nums[j] == f &#123;</span><br><span class="line">        isFound = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !isFound &#123;</span><br><span class="line">      <span class="keyword">return</span> f</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑不多说，这个算法没有利用额外的内存空间，但是时间复杂度为 <code>O(n^2)</code>，是比较低效的，那么这里就需要优化了。</p>
<h2 id="再思考"><a href="#再思考" class="headerlink" title="再思考"></a>再思考</h2><p>再次审题，发现这个题目和之前的一道题目很相似啊，就是有序数组的去重复元素，那道题目解决方法的时间复杂度为 <code>O(n)</code>，所以如果这道题目先把无需数组排序以后再查找重复的，那么时间复杂度肯定是小于 <code>O(n^2)</code> 的，因为快速排序的时间复杂度为 <code>nlog(n)</code>。</p>
<p>按照这个思路实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  sort.Ints(nums)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i+=<span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> nums[i] != nums[i - <span class="number">1</span>] &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums) - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先使用排序方法排序，<code>Golang</code> 的 <code>Ints</code> 排序采用快速排序算法，然后从数组的第一个元素开始遍历，然后以2递增，然后当前元素和前一个元素作比对，如果相同，则有相同元素，如果不相同，则前一个元素为不重复的元素，如果在遍历完成以后没有找到不重复的元素，则表示排序后不重复的元素在最后一个。</p>
<p>这个算法没有使用新的内存空间，时间复杂度为 <code>O(n) + nlog(n)</code>。</p>
<h2 id="再再思考"><a href="#再再思考" class="headerlink" title="再再思考"></a>再再思考</h2><p>我们的目标是 <del>（没有蛀牙）</del> 在保持不使用新的内存空间的前提下，时间复杂度优化到 <code>O(n)</code>。</p>
<p>因为我实在想不到了 <del>（真心不好意思说）</del>，所以就去Google一下，然后真的找到了大神的实现方法，然后跪在屏幕前膜拜一下，方法为：</p>
<blockquote>
<p>异或计算</p>
</blockquote>
<p>Ok，什么叫异或？（赶紧给大学专业课老师烧一炷香吧），简单说就是如果两个数的二进制表示对应为如果相同则为 0，否则为 1。详细的解释去翻书吧。</p>
<p>那么异或计算的最典型的应用就是</p>
<blockquote>
<p>1 ^ 3 ^ 1 = 3</p>
</blockquote>
<p>所以一下就可以看出来了，把数组中每一个元素做异或运算，最终的结果就是不重复的那个元素了。（很巧妙吧，反正我是没想到，因为平时异或运算用的真心不多）。</p>
<p>实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  result := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> _, i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">    result ^= i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的不能再简单了，所以就不解释了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这道题目算是比较简单的，但是要满足空间复杂度和时间复杂度，还是要用到一些不常用的知识，因为异或运算在平时用的很少，所以就几乎遗忘了。通过这道题，把异或计算重新捡起来，巧妙使用真的可以简化很多算法。</p>
<hr>
<p>转载需经作者同意后注明作者名称和文章来源：<br><a href="https://blog.lupub.com/2014/08/10/leetcode-2014-08-10/">https://blog.lupub.com/2014/08/10/leetcode-2014-08-10/</a></p>
</div><div class="tags"><a href="/tags/Golang/">Golang</a><a href="/tags/算法/">算法</a><a href="/tags/LeetCode/">LeetCode</a></div><div class="post-nav"><a href="/2014/10/04/chrome-extension-background-inactive/" class="pre">Chrome Extension 检查视图（无效）处理方法</a><a href="/2014/04/24/leetcode-2014-04-24/" class="next">LeetCode 刷题笔记 - 第二期</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/30/golang-operate-http-header-question-detail/">Golang 操作 HTTP Header 的一个小细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/compare-git-rebase-and-merge/">Git 中 rebase 和 merge 用法经验谈</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/05/redis-transactions-sourcecode/">从源码分析 Redis 事务原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/27/redis-transactions-basic/">浅谈 Redis 事务特性和使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/14/grpc-golang-practice-01/">gRPC 在 Golang 实践 - 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/12/design-pattern-chain-of-responsibiliy/">设计模式 —— 责任链模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/04/16/golang-concurrent-m-p-g-model/">初探 Go 语言并发 M-P-G 模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/03/12/node-js-wechat-card-03/">浅谈微信卡券功能开发（3）</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/02/15/node-js-wechat-card-02/">浅谈微信卡券功能开发（2）</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/02/11/node-js-wechat-card-01/">浅谈微信卡券功能开发（1）</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">LUPUB.com.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?a99b05f84263134db717b3ff13fdaa94";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>