<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一个有思想的程序员的技术博客,Golang,Node.js,Python"><title>LeetCode 刷题笔记 - 第二期 | LUPUB.com</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">LeetCode 刷题笔记 - 第二期</h1><a id="logo" href="/.">LUPUB.com</a><p class="description">一个有思想的程序员</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LeetCode 刷题笔记 - 第二期</h1><div class="post-meta">Apr 24, 2014</div><div class="post-content"><p>今天记录一道题目，距离上一次做题应该有一个多月了，没错，我就是这么的没有毅力…</p>
<p>今天这道题目，开始看标题的时候觉得应该蛮难的，看完题目觉得还好，做完之后觉得也挺简单的，然后再思考一会儿觉得原来这么简单啊…题目如下：</p>
<blockquote>
<p>Best Time to Buy and Sell Stock</p>
<p>Say you have an array for which the ith element is the price of a given stock on day i.<br>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>
<p>大致意思就是，给定一个数组，里面的每一个元素为一天的股票价格，然后设计算法怎么样能够最大化收益。但是不能同时参与多笔交易，也就是说必须卖出之后才能买入。</p>
<p>例如，数组为 <code>[1, 3, 4, 5]</code>，那么最大利润则为 <code>4</code>，即 <code>1</code> 买入，<code>5</code> 卖出。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>看标题 <code>买卖股票的最好时机</code> 应该是蛮高端困难的问题，但是看完题目，其实就是一个数组计算的问题，要是实际股票要是能这样操作，做梦都能乐醒了-.-</p>
<p>废话不多说，这道题目其实就是要检查每一个元素，如果后一个元素比前一个元素小就卖掉，反之买入或者持有（因为同时只能参与一笔交易），按照这种思路，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> buy, profit <span class="keyword">int</span></span><br><span class="line">  <span class="keyword">var</span> isHold <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(prices) - <span class="number">1</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> prices[i + <span class="number">1</span>] &gt; prices[i] &amp;&amp; !isHold &#123;</span><br><span class="line">      buy = prices[i]</span><br><span class="line">      isHold = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> prices[i + <span class="number">1</span>] &lt; prices[i] &amp;&amp; isHold &#123;</span><br><span class="line">      profit += prices[i] - buy</span><br><span class="line">      buy = <span class="number">0</span></span><br><span class="line">      isHold = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> isHold &#123;</span><br><span class="line">    p := prices[<span class="built_in">len</span>(prices) - <span class="number">1</span>] - buy</span><br><span class="line">    profit += p</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> profit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>buy</code> 和 <code>profit</code> 分别表示买入价格和持有的利润，<code>isHold</code> 表示当前为持有状态还是卖出状态，因为当价格为 0 的时候买入和卖出的状态都是 0。<strong>当下个价格比当前价格大并且当前为没有持有的状态时，买入；当下个价格比当前价格小并且当前为持有状态时，卖出。</strong>卖出时计算利润，并且重置 <code>buy</code> 和 <code>isHold</code>。</p>
<h2 id="再思考"><a href="#再思考" class="headerlink" title="再思考"></a>再思考</h2><p>上面的算法已经可以满足题目要求，而且在时间复杂度上也较为理想，（上面算法的时间复杂度为 <code>O(n)</code>），但是，看来看去，实现的都感觉十分繁琐，所以要再考虑有没有更简洁的算法，既要满足时间复杂度和题目要求，同时也要满足代码的<strong><em>优雅度</em></strong>。</p>
<p>再次审题，其实可以发现题目没有限制交易次数，也就是说我们<strong>每次遍历发现后面一个比前面一个小就卖出，反之买入</strong>。</p>
<p>代码如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  profit := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> prices[i] - prices[i - <span class="number">1</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">      profit += prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> profit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样代码看上去比之前的<strong><em>优雅</em></strong>好多，而且时间复杂度也是和之前一样的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然从效率上来讲前后两个算法没有相差多少，但是从代码简洁性看后面的方法要好太多了。但是从思考上可能前者更符合读题时的思路。所以以后在思考上要跳出常规的思维，换一个角度去思考可能会有更好的效果。</p>
<hr>
<p>转载需经作者同意后注明作者名称和文章来源：<br><a href="https://blog.lupub.com/2014/04/24/leetcode-2014-04-24/">https://blog.lupub.com/2014/04/24/leetcode-2014-04-24/</a></p>
</div><div class="tags"><a href="/tags/Golang/">Golang</a><a href="/tags/算法/">算法</a><a href="/tags/LeetCode/">LeetCode</a></div><div class="post-nav"><a href="/2014/08/10/leetcode-2014-08-10/" class="pre">LeetCode 刷题笔记 - 第三期</a><a href="/2014/03/04/leetcode-2014-03-04/" class="next">LeetCode 刷题笔记 - 第一期</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/30/golang-operate-http-header-question-detail/">Golang 操作 HTTP Header 的一个小细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/compare-git-rebase-and-merge/">Git 中 rebase 和 merge 用法经验谈</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/05/redis-transactions-sourcecode/">从源码分析 Redis 事务原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/27/redis-transactions-basic/">浅谈 Redis 事务特性和使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/14/grpc-golang-practice-01/">gRPC 在 Golang 实践 - 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/12/design-pattern-chain-of-responsibiliy/">设计模式 —— 责任链模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/04/16/golang-concurrent-m-p-g-model/">初探 Go 语言并发 M-P-G 模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/03/12/node-js-wechat-card-03/">浅谈微信卡券功能开发（3）</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/02/15/node-js-wechat-card-02/">浅谈微信卡券功能开发（2）</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/02/11/node-js-wechat-card-01/">浅谈微信卡券功能开发（1）</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">LUPUB.com.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?a99b05f84263134db717b3ff13fdaa94";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>