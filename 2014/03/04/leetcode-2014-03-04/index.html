<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一个有思想的程序员的技术博客,Golang,Node.js,Python"><title>LeetCode 刷题笔记 - 第一期 | LUPUB.com</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">LeetCode 刷题笔记 - 第一期</h1><a id="logo" href="/.">LUPUB.com</a><p class="description">一个有思想的程序员</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LeetCode 刷题笔记 - 第一期</h1><div class="post-meta">Mar 4, 2014</div><div class="post-content"><p>最近发现一个刷算法题目的网站，<a href="https://leetcode.com/" target="_blank" rel="noopener">LeetCode</a>，回想一下毕业以后一直在写一些业务，并没有涉及到算法，对于算法的记忆还停留在上学时候的课程里面，所以之后会在这里慢慢回顾一下和算法相关的有关的知识，打好基础才是最重要的。</p>
<p>以后会在这里记录一下刷题时的一些笔记，和总结一些知识点在这里。</p>
<p>因为最近在学习Golang，所以这里的实现会主要以Golang和Node.js来实现。今天先上两道简单入门的算法题目。</p>
<h2 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><code>Two Sum</code> 是一个比较经典算法，就是要求给定一个整数数组和一个目标值，找出数组中和为目标值的两个数的数组下标。</p>
<p>比如给定的数组为 <code>[3, 6, 8, 2]</code>，然后给定的目标值为 <code>9</code>，则返回值为 <code>[0, 1]</code>，即 <code>3</code> 和 <code>6</code> 的下标。</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>看到这个题目，首先想到的就是嵌套两个循环然后求和和目标值进行比对，具体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> result []<span class="keyword">int</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> nums[i] + nums[j] == target &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, i, j)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，这段代码运行是没有问题的，但是，我们可以看到，这里面的两个循环是嵌套的，所以这个函数运行的时间复杂度为 <code>O(n^2)</code>，这个时间复杂度是比较不能够接受的，那我们就应该考虑一种更为效率的方法。</p>
<p>假设我们在第一遍遍历数组的时候，将遍历过的元素存入Hash表中，然后在后面遍历出的元素和Hash表中的元素做计算，因为Hash表的查询的时间复杂度为 <code>O(1)</code>，所以这样的方法最后的时间复杂度为遍历数组的时间复杂度，即为 <code>O(n)</code>。</p>
<h4 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h4><p>按照上面的思路，重新实现一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> results []<span class="keyword">int</span></span><br><span class="line">  mapping := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">  <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算和目标值相差的数值</span></span><br><span class="line">    sub := target - num</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找Map中是否存在这个数值</span></span><br><span class="line">    <span class="comment">// 如果存在，和这个数值相加即为目标值</span></span><br><span class="line">    <span class="comment">// 如果不存在，将这个数值和下标存入Map</span></span><br><span class="line">    <span class="keyword">if</span> v, ok := mapping[sub]; ok &#123;</span><br><span class="line">      results = <span class="built_in">append</span>(results, v, i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mapping[num] = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个 <code>Map</code>，<code>KEY</code> 值为数组中元素的值， <code>VALUE</code> 值为数组中元素的下标值，遍历时，计算出当前元素值和目标值的差，然后在 <code>Map</code> 中查找是否存在和这个差值相等的 <code>Key</code>，如果存在则返回当前元素在数组中的下标和 <code>Map</code> 中这个 <code>Key</code> 对应的 <code>Value</code>。</p>
<p>这样这个函数的时间复杂度为 <code>O(n)</code>，这个时间复杂度在在一个可以接受的范围内。</p>
<h2 id="Reverse-Integer"><a href="#Reverse-Integer" class="headerlink" title="Reverse Integer"></a>Reverse Integer</h2><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>这个题目的要求很简单，给定一个 32 位有符号整数，将整数中的数字进行反转。如果反转后的整数溢出，则返回 0。</p>
<p>比如：给定的数值为 <code>123</code>，反转后的结果为 <code>321</code></p>
<p>比如：给定的数值为 <code>-234</code>，反转后的结果为 <code>-432</code></p>
<p>比如：给定的数值为 <code>340</code>，反转后的结果为 <code>43</code></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在给定整数中可以通过取余数来获取每一位的数值，然后在乘以对应的位数进行反转，所以可以按照这个思路实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  result := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> x != <span class="number">0</span> &#123;</span><br><span class="line">    remainder := x % <span class="number">10</span></span><br><span class="line">    result = result * <span class="number">10</span> + remainder    </span><br><span class="line">    x = (x - remainder) / <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> result &gt; math.MaxInt32 - <span class="number">1</span> || result &lt; math.MinInt32 &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们进行一个循环，然后每次循环对给定的数值除以 10 取余数，取到的余数追加到反转后的数值后面，即为之前反转后的数值扩大 10 倍加上这个数值，即增加一位，原数值减去余数再除以 10，即为减少一位。直到数值减少到 0。</p>
<p>最后由于数值为 <code>int32</code> 类型，所以我们需要判断如果超过 <code>int32</code> 类型所表示的范围，则返回0。</p>
<p>这样这个函数的时间复杂度为 <code>O(n)</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天简单记录两个算法的实现过程，<code>Two Sum</code> 和 <code>Reverse Integer</code>，和对算法的时间复杂度优化。把这两个算法的实现记录下来也便于以后自己查阅，如果有人阅读到这篇文章，而且有更好，更高效的算法，欢迎指导。</p>
<hr>
<p>转载需经作者同意后注明作者名称和文章来源：<br><a href="https://blog.lupub.com/2014/03/04/leetcode-2014-03-04/">https://blog.lupub.com/2014/03/04/leetcode-2014-03-04/</a></p>
</div><div class="tags"><a href="/tags/Golang/">Golang</a><a href="/tags/算法/">算法</a><a href="/tags/LeetCode/">LeetCode</a></div><div class="post-nav"><a href="/2014/04/24/leetcode-2014-04-24/" class="pre">LeetCode 刷题笔记 - 第二期</a><a href="/2012/06/03/java-servlet-405-error-solution/" class="next">关于Servlet报错：405 HTTP method GET is not supported by this URL问题解决方法</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/30/golang-operate-http-header-question-detail/">Golang 操作 HTTP Header 的一个小细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/compare-git-rebase-and-merge/">Git 中 rebase 和 merge 用法经验谈</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/05/redis-transactions-sourcecode/">从源码分析 Redis 事务原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/27/redis-transactions-basic/">浅谈 Redis 事务特性和使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/14/grpc-golang-practice-01/">gRPC 在 Golang 实践 - 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/12/design-pattern-chain-of-responsibiliy/">设计模式 —— 责任链模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/04/16/golang-concurrent-m-p-g-model/">初探 Go 语言并发 M-P-G 模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/03/12/node-js-wechat-card-03/">浅谈微信卡券功能开发（3）</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/02/15/node-js-wechat-card-02/">浅谈微信卡券功能开发（2）</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/02/11/node-js-wechat-card-01/">浅谈微信卡券功能开发（1）</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">LUPUB.com.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?a99b05f84263134db717b3ff13fdaa94";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>